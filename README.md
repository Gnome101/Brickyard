# Brickyard Worker Backend

A Cloudflare Worker that powers the Brickyard design competition API. It exposes three JSON endpoints for generating LEGO models, recording votes, and listing the leaderboard while coordinating with Cloudflare KV, D1, and an upstream Snowflake model service.

## Project Layout
- `worker/src/index.ts` — request routing, validation, caching, Snowflake integration.
- `worker/schema.sql` — D1 schema defining `designs` and `votes` tables.
- `worker/wrangler.toml` — Worker configuration (KV, D1, vars, compatibility date).
- `scripts/mock-snowflake.js` — local HTTP mock of the Snowflake generator.
- `tests/smoke.sh` — curl-based smoke test for `/api/design`, `/api/vote`, `/api/leaderboard`.

Only those files are needed for the backend; anything else generated by Wrangler (`.wrangler`, `.wrangler-logs`, `.npm`, `.dev.vars`, etc.) should remain untracked or be removed after local runs.

## Prerequisites
- Node.js 18+ (Wrangler requires ≥16.13, but 18 keeps parity with Cloudflare’s runtime).
- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/install-and-update/) v3+ authenticated with your Cloudflare account.
- `curl` (already bundled on most systems) for the smoke test script.

## Local Mock Workflow
1. From the repo root, start the mock Snowflake server on port 8788:
   ```sh
   node scripts/mock-snowflake.js 8788
   ```
2. In `worker/`, create a `.dev.vars` file so Wrangler injects the mock endpoint when running locally:
   ```sh
   cd worker
   printf "SNOWFLAKE_ENDPOINT=\"http://127.0.0.1:8788\"\n" > .dev.vars
   ```
   `.dev.vars` is strictly local state—do not commit it.
3. Launch the worker:
   ```sh
   npx wrangler dev --local --port 8787
   ```
   If the simulator cannot bind automatically, add `--ip 127.0.0.1` when you start it.
4. In another terminal (repo root), run the smoke checks against the local worker:
   ```sh
   ./tests/smoke.sh
   ```
   The script prints the full JSON payloads for the three endpoints. Pass a custom base URL as the first argument if you change ports.

Stop the mock server and Wrangler once finished to avoid lingering background processes.

## Using the Real Snowflake API
1. Ensure you have a reachable HTTPS endpoint for your Snowflake model service and any required credentials (e.g., API key).
2. Set secrets for the worker via Wrangler in an environment with a valid `CLOUDFLARE_API_TOKEN`:
   ```sh
   cd worker
   wrangler secret put SNOWFLAKE_ENDPOINT   # enter your production URL
   wrangler secret put SNOWFLAKE_API_KEY    # if your integration needs it
   ```
   Secrets are stored remotely; no files are written to the repo.
3. Run `wrangler dev` (local or remote) and confirm the smoke script succeeds against the real API before deploying.

## Cloudflare Resources
Create backing services once per Cloudflare account (skip if they already exist):
```sh
wrangler d1 create lego_db
wrangler kv namespace create DESIGN_CACHE
wrangler d1 execute lego_db --file=./worker/schema.sql
```
Update the generated IDs in `worker/wrangler.toml` under `kv_namespaces` and `d1_databases`.

## Deployment
```sh
cd worker
wrangler deploy
```
Ensure KV, D1, and required secrets are bound in your Cloudflare account before deploying.

## Troubleshooting Tips
- Wrangler sometimes needs log directories it can write to. If you see permission errors, set `WRANGLER_LOG_DIR` or run from an environment where `~/.config/.wrangler` is writable.
- Local runs that need elevated networking may require `--local --ip 127.0.0.1` or starting Wrangler with additional privileges.
- If you accidentally generate `.wrangler/` or similar state directories, delete them after your session—they are safe to regenerate.

## Next Steps
- Add automated integration tests that spin up the mock Snowflake server and assert cache/vote behavior.
- Hook up CI to run `./tests/smoke.sh` (or a headless equivalent) and `tsc` on every push.
- Add logging/metrics around cache hit rates, Snowflake latency, and error handling.
- Harden rate limiting and input validation according to production requirements.
