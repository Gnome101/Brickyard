# Brickyard Worker Backend

A Cloudflare Worker that powers the Brickyard design competition API. It exposes endpoints for generating LEGO models (as LDraw text), recording votes, and listing the leaderboard while coordinating with Cloudflare KV, D1, and an upstream Snowflake model service.

## Project Layout
- `worker/src/index.ts` — request routing, validation, rate limiting, Snowflake integration.
- `worker/schema.sql` — D1 schema defining `designs` and `votes` tables.
- `worker/wrangler.toml` — Worker configuration (KV, D1, vars, compatibility date).
- `tests/smoke.sh` — curl-based smoke test for `/api/design`, `/api/vote`, `/api/leaderboard`.
- `tests/integration.sh` — simple live checks for `/api/design` and vote flow.
- `tests/full_integration.sh` — comprehensive live test suite.

Only those files are needed for the backend; anything else generated by Wrangler (`.wrangler`, `.wrangler-logs`, `.npm`, `.dev.vars`, etc.) should remain untracked or be removed after local runs.

## Prerequisites
- Node.js 18+ (Wrangler requires ≥16.13, but 18 keeps parity with Cloudflare’s runtime).
- [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/install-and-update/) v3+ authenticated with your Cloudflare account.
- `curl` (already bundled on most systems) for the smoke test script.

## Local Development
Run the Worker locally with Wrangler using your actual upstream settings (or a test endpoint):
```sh
cd worker
npx wrangler dev --port 8787
```
Then run the tests from the repo root, pointing to your local URL if needed:
```sh
HOST=http://127.0.0.1:8787 ./tests/full_integration.sh
```

## Using the Real Snowflake API
The upstream API now expects a POST to an `/api/build` endpoint with `{ "prompt": string, "model": string }` and returns LDraw (`ldrContent`). Example:
```sh
curl -X POST https://<your-snowflake-host>/api/build \
  -H "content-type: application/json" \
  -d '{"prompt":"a small red car","model":"claude-3-5-sonnet"}'
```

The worker forwards the incoming agent name as the `model` value (falling back to `SNOWFLAKE_MODEL` or `claude-3-5-sonnet`), so each requested agent can point at a different upstream model. It remains compatible with the legacy/mock payload shape (`{ model: [...] }`).

1. Ensure you have a reachable HTTPS endpoint for the Snowflake service and any required credentials (e.g., API key).
2. Set secrets for the worker via Wrangler in an environment with a valid `CLOUDFLARE_API_TOKEN`:
   ```sh
   cd worker
   wrangler secret put SNOWFLAKE_ENDPOINT   # e.g., https://lego-ai-service-.../api/build
   wrangler secret put SNOWFLAKE_API_KEY    # if your integration needs it
   wrangler secret put SNOWFLAKE_MODEL      # optional, default: "claude-3-5-sonnet"
   ```
   Secrets are stored remotely; no files are written to the repo.
3. Run `wrangler dev` (local or remote) and confirm the smoke script succeeds against the real API before deploying.

## API Reference

### POST `/api/design`
- Request JSON:
  - `prompt` (string, required)
  - `model` (string, optional) — upstream model name. For compatibility, `agent_type` or the first of `agent_types[]` is also accepted.
  - `seed` (number, optional)
- Response:
  - `text/plain` body containing LDraw `.ldr` content
  - Header `x-request-id` for tracing
- Notes:
  - The worker forwards `model` to the upstream and returns raw `ldrContent` when available.
  - If the upstream returns legacy `{ model: LDrawPart[] }`, the worker converts it to `.ldr` lines.
- Example:
```sh
curl -sS -X POST http://<worker-host>/api/design \
  -H 'content-type: application/json' \
  -d '{
        "prompt":"a small red car",
        "model":"claude-3-5-sonnet",
        "seed":12345
      }'
```
Response (truncated):
```
0 Brickyard Model
1 4 0 0 0 1 0 0 0 1 0 0 0 1 0901.dat
1 4 0 24 0 1 0 0 0 1 0 0 0 1 10314.dat
...
```

### POST `/api/vote`
- Request JSON:
  - `agent_type` (string, required)
  - `prompt` (string, required)
- Response JSON:
  - `leaderboard` — map of agent → total votes
  - `request_id`
- Example:
```sh
curl -sS -X POST http://<worker-host>/api/vote \
  -H 'content-type: application/json' \
  -d '{"agent_type":"claude-3-5-sonnet","prompt":"a small red car"}'
```

### GET `/api/leaderboard`
- Response JSON:
  - `leaderboard` — map of agent → total votes
  - `updated_at` — ISO timestamp
  - `request_id`

### GET `/healthz`
- Response JSON: `{ "ok": true, "request_id": "..." }`

### Error Shape and Common Codes
- All errors return:
  - `{ "error": { "code": string, "message": string, "details": object }, "request_id": string }`
- Common `error.code` values:
  - `VALIDATION_FAILED` — bad input (see `details` for fields)
  - `RATE_LIMITED` — too many requests (see `details.retryAfter`)
  - `GENERATION_TIMEOUT` — upstream Snowflake exceeded timeout
  - `GENERATION_FAILED` — non-OK response or invalid upstream payload
  - `PAYLOAD_TOO_LARGE`, `NOT_FOUND`, `INTERNAL_ERROR`

### Configuration Tips
- `SNOWFLAKE_ENDPOINT` must point to your `/api/build` URL.
- `SNOWFLAKE_TIMEOUT_MS` may need to be ≥ 20000 for internet-facing endpoints.
- `FRONTEND_ORIGIN` controls CORS `access-control-allow-origin`.
- Rate limiting via `RATE_LIMIT_REQUESTS` and `RATE_LIMIT_WINDOW_S` (default 10 per 60s).
- Model selection: the worker uses `model` from the request, falling back to `agent_type`, first of `agent_types[]`, `SNOWFLAKE_MODEL`, then `claude-3-5-sonnet`.

## Cloudflare Resources
Create backing services once per Cloudflare account (skip if they already exist):
```sh
wrangler d1 create lego_db
wrangler kv namespace create DESIGN_CACHE
wrangler d1 execute lego_db --file=./worker/schema.sql
```
Update the generated IDs in `worker/wrangler.toml` under `kv_namespaces` and `d1_databases`.

## Deployment
```sh
cd worker
wrangler deploy
```
Ensure KV, D1, and required secrets are bound in your Cloudflare account before deploying.

## Troubleshooting Tips
- Wrangler sometimes needs log directories it can write to. If you see permission errors, set `WRANGLER_LOG_DIR` or run from an environment where `~/.config/.wrangler` is writable.
- Local runs that need elevated networking may require `--local --ip 127.0.0.1` or starting Wrangler with additional privileges.
- If you accidentally generate `.wrangler/` or similar state directories, delete them after your session—they are safe to regenerate.
